#include "miniRT.h"

static bool	check_cap(const t_cylinder *cl, const t_ray *r, double cap_y, 
					  double *t_cap)
{
	if (fabs(r->direction.y) < 1e-8)
		return (false);
	*t_cap = (cap_y - r->origin.y) / r->direction.y;
	if (*t_cap <= 0)
		return (false);
	t_vec3 hit = ray_at(r, *t_cap);
	double dx = hit.x - cl->center.x;
	double dz = hit.z - cl->center.z;
	return (dx * dx + dz * dz <= cl->radius * cl->radius);
}

static bool	check_cylinder_side(const t_cylinder *cl, const t_ray *r, 
								t_interval ray_t, double *t_side)
{
	double a = r->direction.x * r->direction.x + r->direction.z * r->direction.z;
	double b = 2 * (r->direction.x * (r->origin.x - cl->center.x) + 
				   r->direction.z * (r->origin.z - cl->center.z));
	double c = (r->origin.x - cl->center.x) * (r->origin.x - cl->center.x) + 
			   (r->origin.z - cl->center.z) * (r->origin.z - cl->center.z) - 
			   cl->radius * cl->radius;
	
	double disc = b * b - 4 * a * c;
	if (disc < 0)
		return (false);
	
	double root = (-b - sqrt(disc)) / (2 * a);
	if (root <= ray_t.min || root >= ray_t.max)
		root = (-b + sqrt(disc)) / (2 * a);
	
	if (root <= ray_t.min || root >= ray_t.max)
		return (false);
	
	double y = r->origin.y + root * r->direction.y;
	if (y < cl->center.y || y > cl->center.y + cl->height)
		return (false);
	
	*t_side = root;
	return (true);
}

static t_vec3	get_cylinder_normal(const t_cylinder *cl, const t_vec3 *hit_pos, 
									double hit_t, double t_side, double t_bottom, 
									double t_top)
{
	if (fabs(hit_t - t_side) < 1e-8)
	{
		t_vec3 normal = (t_vec3){hit_pos->x - cl->center.x, 0, hit_pos->z - cl->center.z};
		return (unit_vector(normal));
	}
	else if (fabs(hit_t - t_bottom) < 1e-8)
		return ((t_vec3){0, -1, 0});
	else
		return ((t_vec3){0, 1, 0});
}

static t_vec3 get_cylinder_normal_local(const t_vec3 *hit_local, double hit_t,
                                        double t_side, double t_bottom, double t_top)
{
    if (fabs(hit_t - t_side) < 1e-8)
    {
        t_vec3 normal = (t_vec3){hit_local->x, 0, hit_local->z};
        return (unit_vector(normal));
    }
    else if (fabs(hit_t - t_bottom) < 1e-8)
    {
        return ((t_vec3){0, -1, 0});
    }
    else
    {
        return ((t_vec3){0, 1, 0});
    }
}

bool	cylinder_hit(const t_cylinder *cl, const t_ray *r, t_interval ray_t, 
					 t_hit_record *rec)
{
	t_vec3	u;
	t_vec3	v;
	t_vec3	w;
	t_ray	rotated_r;
	double t_side = INFINITY;
	double t_bottom = INFINITY;
	double t_top = INFINITY;
	double t_min = INFINITY;

	create_orthonormal_basis(&cl->axis, &u, &v, &w);
    rotated_r.origin = world_to_object_space(&r->origin, &cl->center, &u, &v, &w);
    rotated_r.direction = world_to_object_direction(&r->direction, &u, &v, &w);
	if (check_cylinder_side(cl, &rotated_r, ray_t, &t_side))
		t_min = t_side;
	if (check_cap(cl, &rotated_r, cl->center.y, &t_bottom) && 
		t_bottom > ray_t.min && t_bottom < t_min)
		t_min = t_bottom;
	if (check_cap(cl, &rotated_r, cl->center.y + cl->height, &t_top) && 
		t_top > ray_t.min && t_top < t_min)
		t_min = t_top;
	if (t_min == INFINITY)
		return (false);
	t_vec3 hit_local = ray_at(&rotated_r, t_min);
	rec->t = t_min;
	rec->position = object_to_world_space(&hit_local, &cl->center, &u, &v, &w);
	rec->mat = cl->mat;
	t_vec3 normal_local = get_cylinder_normal_local(&hit_local, t_min, 
										t_side, t_bottom, t_top);
	t_vec3 normal_world = object_to_world_direction(&normal_local, &u, &v, &w);
	normal_world = unit_vector(normal_world);
	set_face_normal(r, &normal_world, rec);
	return (true);
}
