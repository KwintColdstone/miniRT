#include "libft/libft.h"
#include "miniRT.h"
#include <fcntl.h>
#include <unistd.h>

bool	is_float(char *s)
{
	int i = 0;
	while (s[i])
	{
		if (!ft_isdigit(s[i]))
		{
			if (s[i] != '.')
				return (false);
		}
		i++;
	}
	return (true);
}

char *subtract_element(char *s, int *i, char delim)
{
	while (s[*i] && ft_isspace(s[*i]))
		*i += 1;
	int j = *i;
	while (s[j] && !ft_isspace(s[j]) && s[j] != delim)
		j++;
	if (s[j] == delim)
		j++;
	*i += j;
	return (ft_substr(s, *i, j - 1));
}

bool	assign_vec3(t_world *world, char *s, double min, double max)
{
	int i = 0;
	t_vec3 v;
	char *x_str = subtract_element(s, &i, ',');
	char *y_str = subtract_element(s, &i, ',');
	char *z_str = subtract_element(s, &i, ' ');
	if (!is_float(x_str) || !is_float(y_str) || !is_float(z_str))
	{
		free(x_str);
		free(y_str);
		free(z_str);
		return (false);
	}
	double x;
	double y;
	double z;
	x = ft_atof(x_str);
	y = ft_atof(y_str);
	z = ft_atof(z_str);
	free(x_str);
	free(y_str);
	free(z_str);
	if (x < min || x > max || y < min || y > max || z < min || z > max)
		return (false);
	
	return (true);
}


bool	parse_ambient(t_world *world, char *line)
{
	int i = 0;
	double amb_strength;
	bool succes;
	char *strength = subtract_element(line, &i, ' ');
	if (!is_float(strength))
	{
		free(strength);
		return (false);
	}
	amb_strength = ft_atof(strength);
	free(strength);
	if (amb_strength < 0.0 || amb_strength > 1.0)
		return (false);
	world->lights.amb.strength = amb_strength;
	char *color = subtract_element(line, &i, ' ');
	succes = assign_vec3(world, color, 0, 255);
	free(color);
	return (succes);
}

bool	parse_camera(t_camera *cam, char *line)
{

	return (true);
}


bool	parse_light(t_world *world, char *line)
{

	return (true);
}


bool	parse_sphere(t_world *world, char *line)
{

	return (true);
}


bool	parse_plane(t_world *world, char *line)
{

	return (true);
}


bool	parse_cylinder(t_world *world, char *line)
{

	return (true);
}


bool	parse_quad(t_world *world, char *line)
{

	return (true);
}

bool	parse(char *file, t_world *world, t_camera *cam)
{
	const int element_count = 10;
	int fd;
	char *line;

	fd = open(file, O_RDONLY);
	line = get_next_line(fd);
	int i = 0;
	int line_count = 1;
	bool succes = true;
	while (line && line[i])
	{
		i = 0;
		char c = line[i];
		while (ft_isspace(c))
			i++;
		if (!ft_isalpha(c))
		{
			printf("parsing failure at line: %d\n", line_count + 1);
			printf("incorrect element type\n");
			return (false);
		}
		int j = i;
		while(line[j] && !ft_isspace(c))
			j++;
		char *id = ft_substr(line, i, j - 1);
		if (ft_strcmp(id, "A"))
		{
			succes = parse_ambient(world, &line[i]);
		}
		else if (ft_strcmp(id, "C"))
		{
			succes = parse_camera(cam, &line[i]);
		}
		else if (ft_strcmp(id, "L"))
		{
			succes = parse_light(world, &line[i]);
		}
		else if (ft_strcmp(id, "sp"))
		{
			succes = parse_sphere(world, &line[i]);
		}
		else if (ft_strcmp(id, "pl"))
		{
			succes = parse_plane(world, &line[i]);
		}
		else if (ft_strcmp(id, "cy"))
		{
			succes = parse_cylinder(world, &line[i]);
		}
		else if (ft_strcmp(id, "qu"))
		{
			succes = parse_quad(world, &line[i]);
		}
		else
		{
			free(id);
			printf("parsing failure at line: %d.\n", line_count);
			printf("element does not exist!\n");
			return (false);
		}
		free(id);
		if (succes == false)
		{
			printf("parsing failure at line: %d.\n", line_count);
			printf("incorrect values for element\n");
			return (false);
		}
		line = get_next_line(fd);
		line_count++;
	}
	return (true);
}
